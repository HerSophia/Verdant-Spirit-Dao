# 存档系统规范 (SAVE_SYSTEM_SPEC.md) v1.0

本文档旨在明确存档系统（新游戏、加载存档、下载存档）的设计哲学和技术实现，确保其严格遵循 `VARIABLES_SPEC.md` 中定义的核心原则。

## 1. 设计哲学：存档即快照

存档系统的核心设计思想是：**存档文件是某一时刻“单一事实来源”（即聊天变量）的完整快照**。

1.  **数据权威性**: 聊天变量 (`Chat Variables`) 是游戏状态的唯一权威。存档系统本身不维护任何状态，它只负责在特定时间点导入或导出这个权威状态。
2.  **无状态操作**: 存档系统的所有操作（保存、加载、新游戏）都是无状态的。它们通过调用 `core/variables.ts` 中提供的全局函数来完成对聊天变量的原子操作，然后通过重新加载页面来确保整个应用从更新后的“单一事实来源”重新初始化。
3.  **用户驱动**: 存档操作完全由用户通过菜单模态框 (`ui/modals/menu.ts`) 发起。

## 2. 存档数据结构

存档 `.json` 文件的根对象就是**完整的聊天变量对象**。其结构必须与 `VARIABLES_SPEC.md` 中定义的结构完全一致。

**示例存档文件内容 (`save.json`)**:
```json
{
  "角色": {
    "主控角色名": "萧栖雪",
    "萧栖雪": {
      "姓名": "萧栖雪",
      "关系": [],
      "物品": [
        { "名称": "潮汐木芯", "数量": 5 },
        { "名称": "《长春诀》拓本", "数量": 1 }
      ]
      // ... 其他所有角色属性 ...
    }
  },
  "世界": {
    "时间": "穿越后第二日 · 清晨",
    "地点": "洄潮屿 · 庇护所",
    "图鉴": {
      "物品": [
        { "名称": "潮汐木芯", "品阶": "凡品中阶", "描述": "..." }
      ],
      "妖兽": [],
      "植物": []
    },
    // ... 其他所有世界属性 ...
  },
  "plugin_storage": {
    "llm_history": {
      // ... 完整的聊天历史记录 ...
    }
  }
}
```

## 3. 核心流程

### 3.1 下载存档 (保存游戏)

1.  **用户触发**: 用户点击菜单模态框中的“下载存档”按钮。
2.  **获取状态**: `ui/modals/menu.ts` 中的事件监听器调用全局函数 `getVariables({ type: 'chat' })`，获取当前聊天变量的完整深拷贝。
3.  **序列化**: 将获取到的变量对象通过 `JSON.stringify` 转换为格式化的JSON字符串。
4.  **创建并下载**: 将JSON字符串转换为 `Blob` 对象，生成一个临时的 `ObjectURL`，并动态创建一个 `<a>` 标签来触发浏览器下载。

### 3.2 加载存档

1.  **用户触发**: 用户点击“加载存档”按钮，并通过文件选择器选择一个 `.json` 存档文件。
2.  **读取文件**: `ui/modals/menu.ts` 使用 `FileReader` API 异步读取文件内容。
3.  **解析与验证**: 文件内容被 `JSON.parse` 解析为JavaScript对象。代码会进行一个基础验证，确保解析结果是一个有效的对象。
4.  **覆盖变量**: 调用 `core/variables.ts` 中导出的 `overwriteAllChatVariables(loadedData)` 函数。该函数会使用加载的数据**完全替换**当前的聊天变量。
5.  **重新加载**: 在变量被成功覆盖后，调用 `window.location.reload()` 重新加载整个应用程序。页面重载后，所有模块（如 `ChatHistoryManager`, `StoryRenderer` 等）都会从这个全新的、已恢复的聊天变量中初始化，从而确保整个应用状态的一致性。

### 3.3 新游戏

1.  **用户触发**: 用户点击“新游戏”按钮并确认。
2.  **清除变量**: `ui/modals/menu.ts` 调用 `core/variables.ts` 中导出的 `clearAllChatVariables()` 函数。该函数会用一个空对象 `{}` 覆盖所有聊天变量。
3.  **清除内存**: 调用 `historyManager.clearInMemoryHistory()` 来清除 `ChatHistoryManager` 实例中的内存缓存，防止在页面重载前出现不一致的状态。
4.  **重新加载**: 调用 `window.location.reload()`。页面重载后，`index.ts` 中的启动逻辑会检测到聊天历史为空，从而自动进入“场景二：新游戏”的流程，并挂载 `SetupModule`。

## 4. 模块职责总结

*   **`ui/modals/menu.ts`**:
    *   **职责**: 提供用户界面，并作为所有存档操作的**发起方**。
    *   **实现**: 监听按钮点击事件，调用 `core/variables.ts` 提供的接口来执行实际的读写操作，并在操作完成后触发页面重载。

*   **`core/variables.ts`**:
    *   **职责**: 提供用于**原子化地**读写“单一事实来源”（聊天变量）的全局函数。
    *   **实现**: 导出 `overwriteAllChatVariables` 和 `clearAllChatVariables` 函数，封装与底层 `updateVariablesWith` API的交互，确保状态的完整替换。

*   **`core/history.ts` & `core/pokedex.ts`**:
    *   **职责**: 在存档系统中，这两个模块是**被动**的。它们在应用启动时从聊天变量中加载自己的初始状态。
    *   **实现**: 它们**不参与**存档的直接读写过程。`ChatHistoryManager` 提供一个 `clearInMemoryHistory` 方法，仅用于在“新游戏”流程中、页面重载前，保持内存状态与已被清空的变量一致。
