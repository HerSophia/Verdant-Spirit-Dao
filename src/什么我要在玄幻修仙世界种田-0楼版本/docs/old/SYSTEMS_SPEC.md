# 系统模块规范 (SYSTEMS_SPEC.md) v3.1

本文档旨在详细描述系统模块 (`core/systems.ts`) 的设计、职责、数据契约以及扩展方法。它与 `RENDERING_SPEC.md` 和 `VARIABLES_SPEC.md` 紧密相关，共同构成了游戏核心功能UI的渲染规范。

## 1. 核心架构：状态与视图分离

游戏内所有系统都遵循**状态（State）**与**视图（View）**彻底分离的核心设计思想。

*   **状态（State）**: 游戏存档中需要被持久化记录的、关于某个系统的数据。例如，成就点数、已解锁的技能列表等。每个系统都有其独立的、在 `世界` 命名空间下的状态存储区（如 `世界.成就`, `世界.技能`）。
*   **视图（View）**：一个轻量级的指针 (`世界.当前激活系统`)，其唯一职责是告诉UI当前应该渲染哪个系统的面板。

这种分离带来了巨大的优势：
*   **逻辑清晰**: 状态的归属非常明确。想找成就数据，就去 `世界.成就`；想知道UI该显示什么，就去 `世界.当前激活系统`。
*   **事件处理器更纯粹**: 事件处理器（如 `newAchievementHandler`）的职责被大大简化，它只关心自己的数据模型，无需了解任何UI状态。
*   **易于调试**: 当UI显示不正确时，可以直接检查对应系统的状态数据是否正确，以及视图控制器 `世界.当前激活系统` 的名称是否正确，问题定位非常快。
*   **面向未来**: 如果未来需要支持更复杂的UI（如一个系统多个子面板），只需扩展视图控制器即可，而无需改动任何系统的核心状态变量。

---

### 完整生命周期案例：成就系统

让我们以“成就系统”为例，走完一个完整的交互生命周期，以更好地理解此架构。

#### **阶段一：游戏开局**
1.  **玩家选择**: 玩家在开局时选择了“成就系统”。
2.  **`系统确认` 事件**: `SetupModule` 生成 `{"type": "系统确认", "payload": { "名称": "成就系统" }}` 事件。
3.  **事件处理**: `systemHandler` 处理器执行，将聊天变量更新为：
    ```json
    "世界": {
      "当前激活系统": { "名称": "成就系统" },
      "成就": { "成就点数": 0, "completed": {} },
    }
    ```

#### **阶段二：首次渲染**
1.  **渲染触发**: 游戏主界面加载，`renderSystem` 函数被调用。
2.  **读取视图控制器**: 函数读取 `世界.当前激活系统.名称`，发现其值为 `"成就系统"`。
3.  **调用具体渲染器**: 根据值，它调用 `renderAchievementSystem()`。
4.  **读取状态数据**: `renderAchievementSystem()` 函数**直接从 `世界.成就`** 中读取数据。
5.  **生成UI**: 根据读取到的数据，渲染出初始的、空的成就面板。

#### **阶段三：玩家交互与状态更新**
1.  **玩家行动**: 玩家在游戏中击败了一只“礁岩拟蟹”，或点击了“兑换奖励”按钮。
2.  **LLM响应**: LLM返回了叙事，并在事件列表中包含了 `"新成就"` 或 `"系统更新"` 事件。
3.  **事件处理**: `achievementSystemHandler` 被调用。它**只读取和更新 `世界.成就`**，可能会写入新成就、增减点数或更新奖励列表。在此过程中，`世界.当前激活系统` 从未被触碰。

#### **阶段四：UI自动刷新**
1.  **渲染触发**: 变量更新后，`renderSystem` 会被自动再次调用。
2.  **重复阶段二的流程**: `renderSystem` 再次读取视图控制器，调用 `renderAchievementSystem`，而 `renderAchievementSystem` 读取到**更新后**的 `世界.成就` 数据，从而将新的成就呈现在UI上。

---

## 2. 核心模块与职责 (`core/systems.ts`)

这是系统渲染的唯一入口和实现中心。

*   **`renderSystem(viewControllerData, container)`**:
    *   **角色**: 中央分发器 (Central Dispatcher)。
    *   **职责**: 这是由主渲染器 `StoryRenderer` 调用的唯一公共函数。它接收 `世界.当前激活系统` 对象作为参数，读取其 `名称` 字段，然后通过一个 `switch` 语句，调用正确的专用渲染函数。
    *   **数据流**: 它**不**传递系统状态数据。专用渲染函数会自行从聊天变量中获取其所需的数据。

*   **`renderSkillPanel(container)`**, **`renderAchievementSystem(container)`**, etc.:
    *   **角色**: 专用系统渲染器。
    *   **职责**: 每个函数负责一个具体系统的UI渲染。它们通过调用 `getVariables()` 直接从聊天变量的独立状态区（如 `世界.技能`, `世界.成就`）读取数据，并生成HTML。

*   **`renderSignInSystem(container)`**:
    *   **角色**: 签到系统渲染器。
    *   **职责**: **完全根据游戏内日期 (`世界.当前日期`) 和 `世界.签到` 驱动**。它会直接读取当前的年份、月份和日期，并渲染对应月份的日历。

*   **`renderBarterSystem(container, pokedexManager)`**:
    *   **角色**: 以物换物系统渲染器。
    *   **职责**: 渲染一个支持多选的交易界面。它会分别列出玩家拥有和商店可提供的物品，并通过复选框让玩家自由选择。界面下方会实时计算并显示双方的价值总和，并根据价值关系启用或禁用交易按钮。

## 3. 数据契约 (Data Contract) v3.0

1.  **视图控制器 (`世界.当前激活系统`)**: `renderSystem` 分发器函数依赖此对象来决定调用哪个渲染器。
2.  **状态数据 (`世界.<系统名>`)**: 每个专用的渲染函数直接读取的、持久化的数据源。

### 3.1 视图控制器契约

*   **路径**: `世界.当前激活系统`
*   **结构**:
    ```json
    {
      "名称": "成就系统" // (必需) 字符串，用于决定调用哪个渲染函数。
    }
    ```

### 3.2 各系统状态数据源 (v2.1 优化)

**核心优化思想**：对于需要频繁查找或更新单个条目的列表（如技能、成就），使用以**唯一ID为键的“字典/映射”结构**，以取代数组，从而实现 O(1) 复杂度的读写操作。

#### 技能面板 (`SYSTEM_SKILL_PANEL`)
*   **UI触发**: `世界.当前激活系统.名称 === '技能面板'`
*   **数据源**: `世界.技能`
*   **结构**:
    ```json
    {
      "skills": {
        "skill_water_1": { "id": "skill_water_1", "名称": "引水咒", "熟练度": 5, "等级": 1 }
      }
    }
    ```

#### 成就系统 (`SYSTEM_ACHIEVEMENT`)
*   **UI触发**: `世界.当前激活系统.名称 === '成就系统'`
*   **数据源**: `世界.成就.已完成`
*   **结构 (v3.1)**:
    ```json
    {
      "成就点数": 10,
      "completed": {
        "achv_first_crab": { "id": "achv_first_crab", "名称": "蟹逅", "描述": "...", "完成时间": "..." }
      },
      "奖励列表": [
        { "id": "reward_001", "名称": "一阶下品聚灵丹", "消耗点数": 50, "库存": 3, "描述": "蕴含微弱灵气，可用于辅助修炼。" }
      ],
      "上次刷新天数": 1
    }
    ```

#### 签到系统 (`SYSTEM_SIGN_IN`)
*   **UI触发**: `世界.当前激活系统.名称 === '签到系统'`
*   **数据源**: `世界.签到`
*   **结构**:
    ```json
    {
      "签到记录": { "Y1M1": [1, 5, 10, 28] },
      "连续签到天数": 5,
      "今日已签到": false,
      "月卡": { "状态": "未激活", "剩余天数": 0 }
    }
    ```

#### 任务系统 (`SYSTEM_QUEST`)
*   **UI触发**: `世界.当前激活系统.名称 === '任务系统'`
*   **数据源**: `世界.任务列表` (详见 `VARIABLES_SPEC.md`)

#### 以物换物 (`SYSTEM_BARTER`)
*   **UI触发**: `世界.当前激活系统.名称 === '以物换物'`
*   **数据源**: `世界.以物换物`
*   **结构**:
    ```json
    {
      "可换取的物品": [
        { "名称": "...", "价值": 180, "库存": 1, "描述": "..." }
      ],
      "上次刷新天数": 1
    }
    ```

#### 传送系统 (`SYSTEM_TELEPORT`)
*   **UI触发**: `世界.当前激活系统.名称 === '传送系统'`
*   **数据源**: `世界.传送点`
*   **结构**:
    ```json
    {
      "已解锁": ["洄潮屿", "青石镇"],
      "当前激活": "洄潮屿"
    }
    ```

## 4. 交互与事件

本模块渲染的UI元素的事件处理逻辑在 `ui/eventHandlers.ts` 中通过事件委托来管理。

*   **成就系统**:
    *   `.achievement-tab-btn`: 位于面板顶部的“成就”和“奖励”标签页切换按钮。这是一个纯前端交互，用于在两个视图之间切换，不直接与LLM通信。
    *   `.clickable-item`: 每个成就项都带有此 `class`，点击时应触发显示详情的模态框。
    *   `#refresh-rewards-btn`: “刷新奖励列表”按钮。点击后，`eventHandlers.ts` 中的逻辑会构建一个系统消息（例如 `[SYSTEM] 【成就奖励系统】：“让我看看……有什么新东西可以给你……”`），并通过 `triggerAction` 发送给LLM，请求更新奖励列表。
    *   `.redeem-btn`: 每个奖励项旁边的“兑换”按钮。点击后，处理器会获取奖励的 `data-reward-id`，构建一个系统消息（例如 `[SYSTEM] 玩家请求兑换成就奖励，奖励ID为: reward_001`），并发送给LLM来处理兑换逻辑。
*   **以物换物**:
    *   `.barter-my-item-checkbox`, `.barter-available-item-checkbox`: 用于选择物品的复选框。它们的 `change` 事件会触发UI上的价值实时计算。
    *   `#execute-barter-btn`: “确认交易”按钮。点击后，`eventHandlers.ts` 中的逻辑会收集所有选中的物品，构建交易请求，并发送给LLM。
    *   `#refresh-barter-btn`: “刷新”按钮。逻辑保持不变，用于请求LLM更新可换取的物品列表。
*   **签到系统**:
    *   `#activate-monthly-card-btn`: “激活月卡”按钮。
    *   `#sign-in-btn`: “今日签到”按钮。

## 5. 如何添加一个新系统 (v2.0 流程)

要向游戏中添加一个新的系统（例如“炼丹系统”），请遵循以下解耦后的步骤：

1.  **定义状态结构**: 在 `VARIABLES_SPEC.md` 中，于 `世界` 命名空间下为新系统添加一个独立的、持久化的状态对象。
2.  **创建Prompt模块**: 在 `src/data/prompts-data.ts` 中为新系统添加Prompt。
3.  **实现事件处理**: 在 `core/events/` 目录下为新系统的事件创建处理器。该处理器**只应**修改对应系统的状态对象。
4.  **创建渲染函数**: 在 `core/systems.ts` 中，创建一个新的渲染函数（例如 `renderAlchemySystem(container)`）。此函数**必须**通过 `getVariables().世界.<新系统名>` 来获取其渲染所需的数据。
5.  **注册分发逻辑**: 在 `core/systems.ts` 的 `renderSystem` 函数的 `switch` 语句中，添加一个新的 `case` 来调用你刚刚创建的渲染函数。
6.  **（可选）更新开局逻辑**: 如果此系统是开局可选的，请确保 `SetupModule` 能正确生成 `"系统确认"` 事件。
