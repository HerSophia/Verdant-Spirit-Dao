# 聊天历史系统性能优化规范 (HISTORY_PERFORMANCE_SPEC.md)

## 1. 背景与挑战

随着游戏对话长度的增加，`ChatHistoryManager` 的性能将成为影响用户体验的关键因素。当前版本使用对象（字典）作为回合的存储结构，虽然在添加和编辑操作上具有 O(1) 的优秀性能，但在“删除一个回合及其后续所有回合”的场景下，其性能复杂度为 O(k)，在最坏情况下为 O(n)。

当回合数达到数百甚至数千时，这种线性复杂度的删除操作可能导致明显的UI卡顿。本规范旨在探讨和设计一套更具扩展性的数据结构，以应对超长对话历史带来的性能挑战。

## 2. 核心性能瓶颈分析

- **主要瓶颈**: `deleteTurn(turnIndex)` 方法。该方法需要遍历并删除从 `turnIndex` 到结尾的所有回合。
- **次要挑战**: 未来可能需要支持在历史记录**中间**插入新回合的功能，当前的对象结构无法高效实现此操作。

## 3. 候选优化方案

### 方案A: 跳表 (Skip List)

- **描述**: 一种基于多层链表的概率性数据结构。底层是一个标准排序链表，上层链表则作为“快速通道”，包含底层链表的部分节点，从而实现快速查找。
- **性能**:
  - **查找/插入/删除**: 平均时间复杂度为 O(log n)。
  - **范围删除 (本案需求)**: 定位到起点是 O(log n)，然后顺序删除，总效率远高于当前方案。
- **优点**:
  - 性能卓越且稳定。
  - 相对于平衡树，实现逻辑更简单直观。
- **缺点**:
  - 空间复杂度更高，需要额外空间存储多层索引。

### 方案B: B+树 (B+ Tree)

- **描述**: 数据库和文件系统中的常用索引结构。它是一种自平衡树，所有数据都存储在叶子节点中，叶子节点之间通过指针相连形成一个有序链表。
- **性能**:
  - **查找/插入/删除**: O(log n)。
  - **范围操作**: 极其高效。删除一个节点及其后续所有节点，只需定位到该节点，然后断开后续链表即可。
- **优点**:
  - 范围操作的性能是所有方案中最好的。
  - 技术成熟，有大量参考实现。
- **缺点**:
  - 实现非常复杂，节点的分裂与合并逻辑繁琐。
  - 主要为磁盘I/O优化，对于纯内存场景可能过于重型。

### 方案C: 分块数据结构 (Rope / Tiered Vector)

- **描述**: 将一个长序列切分成多个固定大小的小数组（块），然后用一个索引结构（如数组或树）来管理这些块。
- **性能**:
  - **访问**: O(1) 或 O(log n)，取决于索引结构。
  - **插入/删除**: 在序列中间操作时，只需修改受影响的块和相邻块，无需移动大量元素，性能接近 O(sqrt(n)) 或 O(log n)。
- **优点**:
  - 在插入和删除操作上，性能优于普通数组。
  - 空间局部性好，缓存友好。
- **缺点**:
  - 实现复杂度中等。
  - 随机访问性能略低于纯数组。

## 4. 结论与选型建议

考虑到我们的核心需求是优化**尾部范围删除**和未来可能的**中间插入**，并且希望实现复杂度可控：

1.  **首选方案: 跳表 (Skip List)**
    它在性能和实现难度之间取得了最佳平衡。O(log n) 的复杂度足以应对上万回合的场景，且代码比B+树更容易维护和调试。

2.  **备选方案: 分块数据结构 (Rope)**
    如果未来的核心操作变为频繁的**中间插入/删除**，Rope将是更优的选择。

**下一步行动**:
在未来的性能优化迭代中，可以考虑将 `ChatHistory` 中 `branches` 的值从 `{ [turnIndex: number]: Turn }` 重构为一个基于**跳表**的自定义数据结构。

## 5. 与事件溯源和状态缓存的协同工作

本规范中讨论的数据结构优化（如跳表）与 `CHAT_FLOW_SPEC.md` 中定义的“事件溯源”和“三级缓存”模型是完全正交且互补的。

*   **职责划分**:
    *   **数据结构 (跳表等)**: 负责高效地**存储和访问** `Turn` 和 `MessagePage` 对象本身。它的核心任务是回答“第N回合的内容是什么？”这类问题。
    *   **事件溯源与缓存**: 负责根据 `MessagePage` 中记录的事件，**计算和恢复**出该时间点的完整游戏状态（`角色`、`世界`变量）。它的核心任务是回答“当这条消息发生时，游戏世界是什么样的？”这类问题。

*   **协同流程 (以`deleteTurn(100)`为例)**:
    1.  **历史数据操作 (高性能)**: 系统利用跳表的 O(log n) 性能，快速地从数据结构中移除了第100回合及其之后的所有 `Turn` 对象。这是一个纯粹的数据层操作。
    2.  **状态重算触发**: 操作完成后，UI会请求将游戏状态同步到最新的第99回合。
    3.  **状态恢复 (高性能)**: `recalculateAndApplyState` 函数被调用。它会利用**L2/L3缓存**机制，找到距离第99回合最近的状态快照（例如第80回合的快照），然后只重放从81到99回合的少量事件，就能快速计算出第99回合的精确状态。

*   **结论**:
    通过这种结合，我们实现了双重性能保障：
    1.  对**对话历史本身**的修改（如删除、插入）是高效的。
    2.  修改历史后，**恢复游戏世界状态**的过程也因缓存机制而同样高效。

    这确保了即使在拥有数千回合的超长存档中，用户进行历史回溯、分支创建或内容编辑等高级操作时，依然能获得流畅的体验。