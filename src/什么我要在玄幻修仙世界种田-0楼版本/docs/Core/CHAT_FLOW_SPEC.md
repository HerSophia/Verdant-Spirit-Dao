# 聊天交互流程规范 (v2.0)

本文档旨在详细描述用户与LLM进行一次完整交互的前端处理流程，以及应用启动时的初始化流程。它与 `VARIABLES_SPEC.md` 和 `data/prompts-data.ts` 共同构成了项目的核心开发规范。

## 0. 应用初始化与状态恢复流程

在用户进行任何交互之前，应用会执行一次性的初始化与状态恢复流程。此流程的目标是精确地将游戏恢复到上次交互结束时的状态，确保数据的一致性和首次交互的正确性。

## 0.1. 新游戏初始化流程 (New Game Initialization Flow)

与状态恢复不同，新游戏的初始化遵循一个独特的流程，旨在根据玩家的选择创建全新的世界状态和第一条故事消息。

**核心流程图**:
`SetupScreen` -> `1. 生成初始状态` -> `MainMenu` -> `2. 触发startGame` -> `index.ts` -> `3. 创建创世消息` -> `4. 保存并加载历史` -> `5. UI渲染`

### 阶段1: 生成初始状态 (责任模块: `stores/setupStore.ts`)

1.  当玩家在 `SetupScreen.vue` 界面点击“确认开局”后，会调用 `setupStore.generateInitialState()`。
2.  此函数根据玩家的所有选择（天赋、地点、物品等）构建一个初始的、不包含任何聊天记录的**状态对象**（包含 `角色` 和 `世界` 变量）。
3.  `SetupScreen.vue` 发出 `complete` 事件，并将此状态对象作为载荷。

### 阶段2: 触发 startGame (责任模块: `MainMenu.vue`, `index.ts`)

1.  `MainMenu.vue` 组件监听 `complete` 事件。
2.  接收到事件后，它会调用在 `index.ts` 中定义的全局函数 `window.startGame(initialState)`，将初始状态对象传递过去。

### 阶段3: 创建创世消息 (责任模块: `index.ts`)

这是新游戏流程的核心，也是先前版本中存在缺陷的地方。正确的流程如下：

1.  **覆盖变量**: `startGame` 函数首先调用 `overwriteAllChatVariables(initialState)`，将玩家选择的初始状态**完整地写入**酒馆的聊天变量中。
2.  **生成创世消息**: 接着，调用 `getGenesisMessage(initialState)`，根据初始状态动态生成第一条故事消息（即“创世消息”）。
3.  **添加消息到历史**: 然后，调用 `historyManager.addAssistantMessagePage(genesisMessage)`，将这条创世消息添加到聊天记录中。**此步骤至关重要**，它确保了游戏历史的第一条记录被正确创建。

### 阶段4: 保存并加载历史 (责任模块: `index.ts`)

1.  在添加创世消息后，`startGame` 函数必须调用 `historyManager.loadHistory()`。
2.  此调用会强制 `ChatHistoryManager` 从刚刚被 `addAssistantMessagePage` 更新过的酒馆变量中**重新读取**完整的聊天记录到其内存缓存中。
3.  **关键点**: 此步骤修复了旧流程中的一个核心缺陷——旧流程在写入创世消息后，会错误地**清空**内存缓存 (`clearInMemoryHistory()`) 而非**重新加载**，导致后续的UI模块无法获取到任何消息。

### 阶段5: UI渲染 (责任模块: `index.ts`, `stores/*.ts`)

1.  在历史记录被正确加载后，`startGame` 调用 `appStore.signalCoreStateReady()`。
2.  后续流程与“状态恢复”中的UI渲染阶段完全相同：`appStore` 的计数器更新，触发所有 store 的 `fetchData` 动作，UI根据最新的、包含创世消息的历史记录进行渲染。

---
**核心流程图**:
`入口 (index.ts)` -> `1. 加载核心服务与数据` -> `2. 状态恢复与变量同步` -> `3. UI渲染` -> `4. 前端UI状态同步`

### 阶段1: 加载核心服务与数据 (责任模块: `index.ts`, `core/pokedex.ts`, `core/storeOrchestrator.ts`)

1. **Pinia 与核心 Store 初始化**: Vue App 和 Pinia 实例首先被创建。
2. **`PokedexManager` 实例化**: 系统初始化图鉴管理器，加载全局图鉴数据。
3. **`ChatHistoryManager` 实例化**: 历史管理器被创建，并立即调用 `loadHistory()` 加载聊天历史。
4. **`StoryRenderer` 实例化**: 渲染器被创建，为后续渲染做准备。
5. **`StoreOrchestrator` 初始化**: 调用 `initializeStoreOrchestrator()`，启动对内部事件总线的监听。**此步骤至关重要**，它确保了在后续的状态恢复和UI渲染过程中，所有模块都能正确响应内部事件。

### 阶段2: 状态恢复与变量同步 (责任模块: `index.ts`, `core/variables.ts`)

这是整个初始化流程的核心，由 `index.ts` 中的 `startGame` 函数驱动，并遵循**事件溯源**原则。

1. **获取最新激活消息**: `index.ts` 首先向 `historyManager` 请求获取当前激活分支的**最后一条AI消息**。
2. **触发状态重算**: `index.ts` 调用 `recalculateAndApplyState(historyManager, lastMessage.id)` 函数。
3. **事件重放 (Replay) 与响应式状态恢复**:
    * `recalculateAndApplyState` 函数从一个干净的**初始状态**或**状态快照**开始。
    * 它通过 `historyManager` 获取到目标消息的**LLM事件链**。
    * **核心协同点**:
        1.  `recalculateAndApplyState` 强制重置核心 stores (`worldStore`, `characterStore`) 到起始状态。
        2.  将所有需要重放的历史事件一次性注入到 `eventLogStore` 中。
        3.  这个注入操作会触发所有监听 `eventLogStore` 的 store 自动进行响应式更新，从而在内存中并行地、异步地重建出目标点的精确状态。
    * 最终，所有 store 的状态都达到了与事件历史完全一致的最终状态。
4. **插件状态重建 (Plugin State Reconstruction)**:
    * 在核心状态（世界、角色）通过事件重放计算完毕后，`recalculateAndApplyState` 函数会接着获取到目标消息为止的**完整消息历史记录**。
    * 它会调用所有相关插件模块（如 `smartContextStore`）的 `rebuildStateFromHistory(messages)` 方法。
    * 各个插件的 store 会遍历这段历史，并根据附加在消息页上的**插件事件 (`pluginEvents`)**，同步地、确定性地重建其内部状态。**此过程不涉及任何网络请求**。
5. **原子化覆盖**: 当所有核心事件和插件事件都重放完毕后，`recalculateAndApplyState` 会使用刚刚在内存中计算出的、完全精确的**核心状态**（世界、角色），**一次性、完整地覆盖**当前的聊天变量。插件的状态则保留在各自的 Pinia store 内存中。
6. **结果**: 此步骤完成后，核心聊天变量和所有插件的内存状态都被精确恢复到上次交互结束时所激活的消息页对应的状态，共同构成了UI渲染的“单一事实来源”。

### 阶段3: UI渲染 (责任模块: `stores/*.ts`, `core/reactiveMessageBus.ts`)

1.  在 `recalculateAndApplyState` 或 `worldStore` 自身初始化成功后，会通过 `reactiveMessageBus` 发出相应的事件信号（如 `variablesSynced`, `worldStoreInitialized`）。
2.  **事件驱动的初始化**: 各个 Pinia stores 不再监听一个统一的全局信号，而是根据自身的具体数据依赖，精确地监听与之相关的事件。
    *   **依赖基础世界数据**: `timeStore`, `weatherStore`, `shelterStore`, `mapStore` 等直接依赖 `世界` 变量基础结构的 store，会监听 `worldStoreInitialized` 事件来触发它们的 `fetchData` 动作。
    *   **依赖完整重算状态**: `questStore`, `relationsStore`, `skillStore`, `barterStore` 等需要读取经过事件重放后的完整角色或世界状态的 store，会监听 `variablesSynced` 事件。这个事件在 `recalculateAndApplyState` 成功将重算后的状态写入变量后发出，确保了数据源的准确性。
    *   **特殊情况 (`pokedexStore`)**: `pokedexStore` 的数据现在由 `worldStore` 统一管理。因此，它的数据更新与 `worldStore` 同步，UI 通过 `computed` 属性响应 `worldStore` 的变化，不再需要监听 `variablesSynced` 来进行独立的数据拉取。
3.  **数据驱动视图**: 各个 store 在接收到各自的精确信号后，从已准备好的聊天变量中获取最新数据并更新自身状态。由于 Vue 的响应式系统，所有绑定了这些 store 数据的 UI 组件都会**自动、精确地重新渲染**。

### 阶段4: 前端UI状态同步 (责任模块: `index.ts`)

在所有核心数据和UI渲染完成后，流程返回到 `index.ts`，进行最后的界面状态对齐，确保前端的Swipes状态与历史记录的最新状态保持完全同步。

---

## 核心交互流程

`用户输入` -> `1. 构造请求` -> `LLM` -> `2. 统一事件流处理` -> `3. 最终渲染与保存` -> `完成`

## 各阶段详解

### 1. 构造并发送请求 (责任模块: `core/actions.ts`, `core/promptManager.ts`)

当用户点击一个行动选项或请求新回复时，相应的动作函数 (`triggerAction` 或 `generateAnotherSwipe`) 在 `core/actions.ts` 中被调用。

1. **区分交互类型**: `actions.ts` 首先判断本次生成的类型：
    * **推进新回合 (New Turn)**: 用户在第N回合做出选择，请求生成第N+1回合的内容。
    * **探索可能性 (Retry/Swipe)**: 用户在第N+1回合对某个回复不满意，请求生成一个**同回合的**新回复。

2. **获取上下文状态**:
    * `actions.ts` 调用 `promptManager.preparePromptComponents()`。
    * `promptManager` 内部逻辑会根据交互类型，智能地获取正确的上下文状态：
        * **如果是“推进新回合”**: 它会获取**当前激活消息页**所对应的状态，作为增量更新的基础。
        * **如果是“探索可能性”**: 它会执行**状态回溯**，获取**上一个回合（第N回合）的最终状态**，作为生成全新可能性的基础。

3. **组装并发送请求**:
    * `promptManager` 返回包含正确上下文状态和相应历史记录的组件。
    * `actions.ts` 将这些组件传递给 `generation.ts`，发送给LLM。

### 2. 统一的AI响应生命周期 (责任模块: `index.ts` 中的AI事件监听器)

为了同时支持**流式**和**非流式**响应，我们设计了一套统一的事件处理生命周期。

1. **`GENERATION_STARTED`**: 标志着AI已开始处理请求，UI进入加载状态。

2. **`STREAM_TOKEN_RECEIVED_FULLY` (仅限流式)**: 持续用收到的文本更新UI，实现打字机效果。**此阶段不处理状态**。

3. **`GENERATION_ENDED` (生命周期结束)**:
    * **触发**: 标志着AI已返回**最终且完整**的回复。
    * **核心操作 (`onGenerationEnded` 函数)**:
        * **文本预处理与历史保存**: 对收到的最终文本进行正则处理，并将其作为新的消息页保存到 `historyManager` 中。
        * **区分情景进行状态更新**:
            * **如果是“推进新回合”**: 调用 `syncVariables` 函数。该函数从新消息中解析事件，并将其**增量**应用到当前状态上，然后将更新后的状态写回聊天变量。
            * **如果是“探索可能性” (Swipe/Retry)**: 调用 `recalculateAndApplyState` 函数。该函数会基于**上一回合**的状态，结合新消息的事件，**完整地重算**出当前分支的精确状态，并将其写回聊天变量。
        * **触发插件后台任务**: 在状态更新完成后，会异步触发所有需要在回合结束时运行的插件模块，例如 `ContextLinker` (智能上下文学习) 和 `Summarizer` (自动摘要)。
            * **关键点**: 在正常的“在线”游戏流程中，这些模块会执行其异步操作（如调用次级LLM），并将结果封装成一个**插件事件**，通过 `historyManager.addPluginEvent()` 附加到当前的消息页上进行持久化。它们**不会直接修改**核心的游戏状态变量。
        * **触发全局UI刷新**:
            1.  在状态更新（`syncVariables` 或 `recalculateAndApplyState`）的末尾，会发出 `variablesSynced` 事件。
            2.  各个UI相关的 store（如 `storyStore`, `actionStore`）会监听此事件，并触发各自的 `fetchData` 动作，从更新后的聊天变量中获取最新数据并刷新UI。
        * **重置状态标志**: 将 `isAiGenerating` 等前端状态标志复位。

---

## 3. 状态管理核心：三级缓存与平行时空模型

为了从根本上解决因重试（切换Swipe）导致的状态污染问题，并兼顾性能，系统采用了一套基于**事件溯源**和**三级缓存**的“平行时空”模型。

### 核心原则：消息页的独立性

在游戏过程中，同一个AI回合内的不同消息页（Swipes）之间，**不存在任何时空上的直接继承关系**。它们是基于**同一个父消息**（即上一个回合的最终状态）生成的、完全独立的**可能性分支**，如同不同的“平行时空”。

### 状态回溯的三级缓存策略

为了在不同场景下高效、准确地获取状态，系统采用三级缓存策略来寻找事件重放的“起点”。

* **L1 缓存 (热缓存): 上一回合的最终状态**
  * **定义**: 指第N-1回合的最终状态。这是一个高频访问的、临时的内存状态，不被持久化。
  * **用途**: 专门用于在当前回合（第N回合）内**生成**新的可能性（Swipes）。这是最高效的回溯路径。

* **L2 缓存 (温缓存): 分支状态快照**
  * **定义**: 周期性（例如每20回合）保存的、持久化在 `世界.{分支ID}.状态快照` 中的完整游戏状态。**每个分支拥有独立的快照集**。
  * **用途**: 用于**查看**或**回溯**到较远的历史消息页，或**创建新分支**时，作为事件重放的起点，是长距离跳转的性能保障。

* **L3 缓存 (冷缓存): 游戏初始状态**
  * **定义**: 游戏开局时生成的、持久化在 `世界.初始状态` 中的“创世快照”。同时，会在 `备份.初始状态备份` 中创建一个完全相同的冗余备份。
  * **用途**: 作为所有状态计算的最终基石。当没有任何L2快照可用时，系统会优先从 `世界.初始状态` 开始重放事件。如果 `世界.初始状态` 检测到损坏或不存在，系统会自动尝试从 `备份.初始状态备份` 加载，确保绝对的状态准确性和存档韧性。

### 场景一: 请求生成同一回合的新消息页 (使用 L1 缓存)

当用户请求**生成**一个新的Swipe（例如点击“重试”）时，系统执行**状态回溯**。

1. **触发**: `core/actions.ts` 中的 `generateAnotherSwipe` 被调用。
2. **回溯至分叉点 (访问L1缓存)**: `PromptManager` 忽略当前激活的Swipe的状态，直接获取**上一个回合的最终状态**。
3. **基于共同起点生成**: 系统使用这个L1缓存的状态作为上下文，请求生成一个全新的“平行时空”。
4. **应用增量更新**: 新消息返回后，其事件被应用到**L1缓存状态**上，形成一条新的、独立的世界线状态。

### 场景二: 切换并查看已存在的消息页 (智能缓存调度)

当用户在**当前楼层**内，通过左右滑动(Swiper)来**切换**不同的消息页时，系统会执行一次**状态重算**以更新世界状态。

1. **触发**: 用户滑动Swiper， `recalculateAndApplyState(targetMessageId)` 被调用。
2. **计算逻辑**:
    * 系统会智能地利用 **L2/L3 缓存**，找到最近的快照，并重放事件直到目标消息页，计算出该点的权威状态。
3. **UI刷新**:
    * 计算出的精确状态被用于覆盖当前变量。
    * `index.ts` 监听到由 `historyManager` 派发的 `stateActivationRequested` 事件后，调用 `appStore.signalCoreStateReady()`。
    * 所有 Pinia stores 响应信号，自动从更新后的变量中获取数据并刷新UI。
4. **只读查看**: 如果用户是查看**历史消息记录**中的某个消息页，这**仅供查阅**，不会触发状态重算，也不会对当前的游戏状态做任何数据上的改动。

### 场景三: 从历史消息创建新分支 (使用 L2/L3 缓存)

当用户从一个历史节点**创建新分支**时，系统执行一次**状态重算**来确立新分支的起点。

1. **触发**: 用户通过UI操作，选择一个历史消息页作为“分叉点”，触发 `historyManager.createBranch(fromMessageId,targetSwipeId)`。
2. **计算起点状态**:
    * 为了获取分叉点的精确状态，系统会执行与**查看历史消息**完全相同的逻辑。
    * 它会智能地利用 **L2/L3 缓存**，找到最近的快照，并重放事件直到分叉点，计算出该点的权威状态。
3. **建立新分支**:
    * `historyManager` 创建一个新的分支ID。
    * 计算出的起点状态成为新分支的第一个**L1缓存**。
    * 新分支的**L2缓存 (`世界.{分支ID}.状态快照`)** 会从旧分支**复制**而来，但**不包含**分叉点之后（楼层更高）的那些状态快照。
    * 游戏流程切换到这个新分支上，重新渲染整个页面，后续操作将在新世界线中进行。

---

## 4. 健壮性与未来兼容性考量

为了确保系统在长期迭代和各种意外情况下的稳定性，特补充以下规范。

### 4.1 L2缓存（状态快照）的版本管理

* **问题**: 随着业务逻辑的迭代，状态计算规则或事件结构可能发生变化，导致新版代码无法处理旧版快照。
* **解决方案**:
  * **快照版本控制**: 每个L2快照都必须包含一个 `version` 字段。
  * **兼容策略**:
    * **向后兼容**: 新版本代码应尽可能兼容旧版快照。
    * **失效回退**: 当加载到一个不兼容的快照时，系统必须能够优雅地忽略它，并自动寻找更早的、兼容的快照或直接回退到L3（初始状态）进行重算。重算成功后，应生成新版本的L2快照。
    * **迁移脚本 (可选)**: 对于重大变更，可提供一次性的数据迁移脚本，用于升级旧快照。

### 4.2 事件流的容错处理

* **问题**: 历史记录中可能因意外（如网络错误、LLM格式异常）混入损坏的事件，导致事件重放失败，使存档无法加载。
* **解决方案**:
  * **增强 store watcher 的容错能力**: 在各个 store 中处理事件的 `watch` 回调函数内部，必须使用 `try...catch` 块进行包裹。
  * **错误处理策略**:
    * **记录与隔离**: 捕获到异常时，必须详细记录错误的事件内容、消息ID及错误信息。
    * **跳过损坏事件**: 为保证游戏的可玩性，系统应选择“跳过”该损坏事件并继续处理后续事件。虽然这可能导致轻微的状态不一致，但优先保证了存档的可加载性。

### 4.3 抑制重算期间的错误提示

* **问题**: 在加载存档或切换 `Swipe` 时，系统会重放历史事件来重建状态。这个过程中，一些在旧版本中有效、但在新版本中被视为逻辑错误（如时间倒流）的事件会被反复触发，导致不必要的错误弹窗，干扰用户体验。
* **解决方案**:
  * **引入全局状态标志**: 在 `core/state.ts` 中引入一个全局标志 `isRecalculatingState`。
  * **流程包裹**: 在 `index.ts` 中，任何调用 `recalculateAndApplyState` 的地方，都会在此函数执行前将 `isRecalculatingState` 设为 `true`，并在执行完毕后设为 `false`。
  * **条件化错误提示**: 在事件处理器（如 `worldChangeHandler.ts`）中，当检测到逻辑错误并准备弹出 `toastr` 提示前，会先检查 `getIsRecalculatingState()` 的值。如果为 `true`，则抑制该次弹窗，只在日志中记录错误。
  * **效果**: 确保了只有在正常的游戏流程中发生的实时错误才会通知用户，而在后台状态重建过程中发生的、可预期的历史逻辑冲突则会被静默处理。

## 5. 插件模块与状态重算协同规范

为了让 `SMART_CONTEXT`、`AUTO_SUMMARY` 等依赖异步操作和自身状态的插件模块能够与核心的状态重算机制无缝协作，所有插件都必须遵循以下设计规范。

### 5.1 核心原则：插件活动必须是可重放的确定性过程

所有插件的行为必须被清晰地划分为两个阶段，以确保其状态能够被精确地回溯和重建：

*   **在线生成阶段 (Live Generation)**:
    *   **触发时机**: 在正常的游戏流程中，当满足特定条件时（如 `GENERATION_ENDED` 事件触发）。
    *   **行为**: 插件可以执行异步操作，如调用次级LLM API。
    *   **核心产物**: 操作完成后，插件**必须**将其结果封装成一个或多个**插件事件 (Plugin Events)**。
    *   **持久化**: 这些插件事件通过 `historyManager.addPluginEvent(messageId, event)` 方法，作为元数据附加到触发它的消息页上，并随聊天记录一同保存。**插件绝对不能在此阶段直接修改由事件溯源管理的核心状态**（如 `世界` 或 `角色` 变量）。

*   **离线重算阶段 (Offline Recalculation)**:
    *   **触发时机**: 当 `recalculateAndApplyState` 函数被调用时（如切换Swipe、加载存档）。
    *   **行为**: 插件**严禁**执行任何异步或非确定性操作（如网络请求）。
    *   **核心产物**: 插件的 store 必须提供一个 `rebuildStateFromHistory(messages)` 方法。此方法接收一段消息历史作为输入。
    *   **状态重建**: 在此方法内部，插件会清空其当前状态，然后遍历输入的消息历史，通过处理其中包含的**插件事件**，来完全地、同步地、确定性地重建其内部状态。

### 5.2 数据结构：插件事件 (`pluginEvents`)

为了支持上述流程，`MessagePage` 的数据结构被扩展，增加了一个可选的 `pluginEvents` 字段。

```typescript
// in core/history.ts
export interface MessagePage {
  // ... existing fields
  pluginEvents?: PluginEvent[];
}

export type PluginEvent = 
  | { type: 'ContextLinkerRan'; updates: KeywordUpdate[]; ... }
  | { type: 'SummaryCreated'; summaryText: string; ... };
```

### 5.3 流程总结

通过将插件的活动本身也“事件化”，我们将其无缝地融入了核心的“平行时空”模型。这确保了无论用户如何跳转、分支或读档，整个应用的状态（包括所有插件的状态）始终是**100%可预测和一致的**，从根本上杜绝了状态污染问题。

---

## 流程总结

通过这套严格区分的流程和三级缓存机制，我们确保了：

* **数据源唯一**: 所有UI展示都源于聊天变量这一“单一事实来源”。
* **状态变更可预测**: 状态的演进（新回合）是增量的，而状态的切换（查看历史）是基于缓存重算的。
* **可能性的独立性**: 同一回合内的所有生成选项都基于L1缓存（上一回合状态），保证了“平行时空”的纯粹性。
* **高性能与高精度**: 三级缓存策略在不同场景下取得了性能与准确性的最佳平衡。
* **模块职责清晰**: 各模块各司其职，逻辑高度解耦，便于维护和调试。
